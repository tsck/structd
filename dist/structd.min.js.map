{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///structd.min.js","webpack:///webpack/bootstrap 9918e679a8f010d68b77","webpack:///./src/index.js","webpack:///./src/structures/linked-list/LinkedList.js","webpack:///./src/structures/queue/Queue.js","webpack:///./src/structures/binary-search-tree/BSTNode.js","webpack:///./src/structures/binary-search-tree/BinarySearchTree.js","webpack:///./src/structures/graph/Graph.js","webpack:///./src/structures/hash-table/HashCodes.js","webpack:///./src/structures/hash-table/HashTable.js","webpack:///./src/structures/hash-table/ValuePair.js","webpack:///./src/structures/linked-list/LinkedListNode.js","webpack:///./src/structures/stack/Stack.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","Graph","BinarySearchTree","HashTable","LinkedList","Queue","Stack","undefined","_Stack","_Queue","_LinkedList","_HashTable","_BinarySearchTree","_Graph","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_LinkedListNode","head","element","node","LinkedListNode","current","next","position","prevPosition","prevNode","nextNode","indexOf","removeAt","index","string","substring","map","WeakMap","set","queue","get","toString","shift","push","splice","BSTNode","left","right","minNode","maxNode","searchNode","removeNode","tmp","inOrderTraverseNode","callback","preOrderTraverseNode","postOrderTraverseNode","insertNewNode","newNode","_BSTNode","_verticesMap","Map","_connectionsMap","v","vertex","vertArr","connections","disconnect","vertex1","vertex2","arr1","arr2","output","y","findIndex","color","enqueue","isEmpty","u","dequeue","neighbors","w","distances","simpleHashCode","hash","charCodeAt","_HashCodes","_ValuePair","table","append","ValuePair","remove","stack","pop"],"mappings":"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","file":"structd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"structd\"] = factory();\n\telse\n\t\troot[\"structd\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"structd\"] = factory();\n\telse\n\t\troot[\"structd\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Graph = exports.BinarySearchTree = exports.HashTable = exports.LinkedList = exports.Queue = exports.Stack = undefined;\n\t\n\tvar _Stack = __webpack_require__(10);\n\t\n\tvar _Queue = __webpack_require__(2);\n\t\n\tvar _LinkedList = __webpack_require__(1);\n\t\n\tvar _HashTable = __webpack_require__(7);\n\t\n\tvar _BinarySearchTree = __webpack_require__(4);\n\t\n\tvar _Graph = __webpack_require__(5);\n\t\n\texports.Stack = _Stack.Stack;\n\texports.Queue = _Queue.Queue;\n\texports.LinkedList = _LinkedList.LinkedList;\n\texports.HashTable = _HashTable.HashTable;\n\texports.BinarySearchTree = _BinarySearchTree.BinarySearchTree;\n\texports.Graph = _Graph.Graph;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.LinkedList = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _LinkedListNode = __webpack_require__(9);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/** Class representing a singly linked list of elements. */\n\tvar LinkedList = exports.LinkedList = function () {\n\t  /**\n\t   * Creates a linked list.\n\t   */\n\t  function LinkedList() {\n\t    _classCallCheck(this, LinkedList);\n\t\n\t    this.length = 0;\n\t    this.head = null;\n\t  }\n\t\n\t  /**\n\t   * Appends an element to the end of list.\n\t   * @param {*} element - Element to be appended to list.\n\t   */\n\t\n\t\n\t  _createClass(LinkedList, [{\n\t    key: 'append',\n\t    value: function append(element) {\n\t      var node = new _LinkedListNode.LinkedListNode(element),\n\t          current = void 0;\n\t\n\t      // Check if this is 1st item in list\n\t      if (this.head === null) {\n\t        this.head = node;\n\t      } else {\n\t        current = this.head;\n\t\n\t        // Loop to last node in list\n\t        while (current.next) {\n\t          current = current.next;\n\t        }\n\t\n\t        current.next = node;\n\t      }\n\t\n\t      this.length++;\n\t    }\n\t\n\t    /**\n\t     * Inserts an element into the list at a given position.\n\t     * @param {number} position - Position to insert new element.\n\t     * @param {*} element - Element to be inserted into list.\n\t     */\n\t\n\t  }, {\n\t    key: 'insert',\n\t    value: function insert(position, element) {\n\t      var node = new _LinkedListNode.LinkedListNode(element),\n\t          prevPosition = position - 1,\n\t          prevNode = this.head,\n\t          nextNode = void 0;\n\t\n\t      // Get previous element\n\t      for (var i = 0; i < prevPosition; i++) {\n\t        prevNode = prevNode.next;\n\t      }\n\t\n\t      nextNode = prevNode.next;\n\t      prevNode.next = node;\n\t      node.next = nextNode;\n\t    }\n\t\n\t    /**\n\t     * Removes element from list at given position\n\t     * @param {number} position - Position where element to be removed is.\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAt',\n\t    value: function removeAt(position) {\n\t      if (position > -1 && position < this.length && this.head != null) {\n\t        var prevPosition = position - 1,\n\t            current = this.head;\n\t\n\t        if (position === 0) {\n\t          this.head = current.next;\n\t        } else {\n\t          // Get previous element\n\t          for (var i = 0; i < prevPosition; i++) {\n\t            current = current.next;\n\t          }\n\t\n\t          // Assign previous elements next to the element after the element being\n\t          // replaced\n\t          current.next = current.next.next;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes given element from list.\n\t     * @param {*} element - Element to be removed.\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(element) {\n\t      var position = this.indexOf(element);\n\t      this.removeAt(position);\n\t    }\n\t\n\t    /**\n\t     * Get the index of a given element.\n\t     * @param {*} element - Element who's index is needed.\n\t     * @returns {number} Index of given element.\n\t     */\n\t\n\t  }, {\n\t    key: 'indexOf',\n\t    value: function indexOf(element) {\n\t      var index = 0,\n\t          current = void 0;\n\t\n\t      if (this.head) {\n\t        current = this.head;\n\t        while (current) {\n\t          if (current.element === element) return index;\n\t          index++;\n\t          current = current.next;\n\t        }\n\t      }\n\t\n\t      // Will only be reached if element not found in list\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Checks whether or not the list is empty.\n\t     * @returns {boolean} True if the list's empty, false if it's not.\n\t     */\n\t\n\t  }, {\n\t    key: 'isEmpty',\n\t    value: function isEmpty() {\n\t      return this.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets the size of list.\n\t     * @returns {number} The size of list.\n\t     */\n\t\n\t  }, {\n\t    key: 'size',\n\t    value: function size() {\n\t      return this.length;\n\t    }\n\t\n\t    /**\n\t     * Get a string representation of the list.\n\t     * @returns {string} The string representation of list.\n\t     */\n\t\n\t  }, {\n\t    key: 'toString',\n\t    value: function toString() {\n\t      var current = this.head,\n\t          string = '';\n\t\n\t      while (current) {\n\t        string += current.element + ', ';\n\t        current = current.next;\n\t      }\n\t\n\t      // Remove trailing space and comma\n\t      string = string.substring(0, string.length - 2);\n\t\n\t      return string;\n\t    }\n\t  }]);\n\n\t  return LinkedList;\n\t}();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar map = new WeakMap();\n\t\n\t/** Class representing a first-in-first-out (FIFO) queue of elements. */\n\t\n\tvar Queue = exports.Queue = function () {\n\t  /**\n\t   * Creates a queue.\n\t   */\n\t  function Queue() {\n\t    _classCallCheck(this, Queue);\n\t\n\t    map.set(this, []);\n\t  }\n\t\n\t  /**\n\t   * Get a string representation of queue.\n\t   * @returns {string} The string representation of queue.\n\t   */\n\t\n\t\n\t  _createClass(Queue, [{\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      var queue = map.get(this);\n\t      return queue.toString();\n\t    }\n\t\n\t    /**\n\t     * Removes the first element from the queue.\n\t     * @returns {*} Element removed from queue.\n\t     */\n\t\n\t  }, {\n\t    key: \"dequeue\",\n\t    value: function dequeue() {\n\t      var queue = map.get(this);\n\t      return queue.shift();\n\t    }\n\t\n\t    /**\n\t     * Places an element onto queue.\n\t     * @param {*} element - Element to be added to queue.\n\t     */\n\t\n\t  }, {\n\t    key: \"enqueue\",\n\t    value: function enqueue(element) {\n\t      var queue = map.get(this);\n\t      queue.push(element);\n\t    }\n\t\n\t    /**\n\t     * Gets the size of queue.\n\t     * @returns {number} The size of queue.\n\t     */\n\t\n\t  }, {\n\t    key: \"size\",\n\t    value: function size() {\n\t      var queue = map.get(this);\n\t      return queue.length;\n\t    }\n\t\n\t    /**\n\t     * Checks whether queue is empty.\n\t     * @returns {boolean} True if empty, false if not.\n\t     */\n\t\n\t  }, {\n\t    key: \"isEmpty\",\n\t    value: function isEmpty() {\n\t      var queue = map.get(this);\n\t      return queue.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets first element of queue without removing it.\n\t     * @returns {*} First element of queue.\n\t     */\n\t\n\t  }, {\n\t    key: \"front\",\n\t    value: function front() {\n\t      var queue = map.get(this);\n\t      return queue[0];\n\t    }\n\t\n\t    /**\n\t     * Removes all elements from queue.\n\t     */\n\t\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      var queue = map.get(this);\n\t      queue.splice(0, queue.length);\n\t    }\n\t  }]);\n\n\t  return Queue;\n\t}();\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar BSTNode = exports.BSTNode = function BSTNode(key) {\n\t    _classCallCheck(this, BSTNode);\n\t\n\t    this.key = key;\n\t    this.left = null;\n\t    this.right = null;\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.BinarySearchTree = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _BSTNode = __webpack_require__(3);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// --------------------------------------------------------------------\n\t// Private Methods\n\t// --------------------------------------------------------------------\n\t\n\tfunction minNode(node) {\n\t    if (node && node.left !== null) {\n\t        return minNode(node.left);\n\t    } else {\n\t        return node.key;\n\t    }\n\t}\n\t\n\tfunction maxNode(node) {\n\t    if (node && node.right !== null) {\n\t        return maxNode(node.right);\n\t    } else {\n\t        return node.key;\n\t    }\n\t}\n\t\n\tfunction searchNode(node, key) {\n\t    if (node === null) {\n\t        return false;\n\t    }\n\t\n\t    if (node.key === key) {\n\t        return true;\n\t    }\n\t\n\t    if (key < node.key) {\n\t        return searchNode(node.left, key);\n\t    } else {\n\t        return searchNode(node.right, key);\n\t    }\n\t}\n\t\n\t// Method remove the node with matching key from the tree and returns it\n\tfunction removeNode(node, key) {\n\t    // make sure node exists\n\t    if (node === null) {\n\t        return null;\n\t    }\n\t\n\t    // If the current node's key is not the correct key, remove it and return it\n\t    if (key === node.key) {\n\t\n\t        // Case 1: The node is a leaf node\n\t        if (node.left === null && node.right === null) {\n\t            node = null;\n\t            return node;\n\t        }\n\t\n\t        // Case 2: The node only has a right child\n\t        if (node.left === null) {\n\t            node = node.right;\n\t            return node;\n\t        }\n\t\n\t        // Case 3: The node only has a left child\n\t        if (node.right === null) {\n\t            node = node.left;\n\t            return node;\n\t        }\n\t\n\t        // Case 4: The node as 2 children\n\t        var tmp = minNode(node.right);\n\t        node.key = tmp.key;\n\t        node.right = removeNode(node.right, tmp.key);\n\t        return node;\n\t    }\n\t\n\t    // If the current node's key is not the correct key, find the right node by\n\t    // traversing down either the left branch or right branch recursively\n\t    if (key < node.key) {\n\t        node.left = removeNode(node.left, key);\n\t        return node;\n\t    } else if (key > node.key) {\n\t        node.right = removeNode(node.right, key);\n\t        return node;\n\t    }\n\t}\n\t\n\tfunction inOrderTraverseNode(node, callback) {\n\t    if (node !== null) {\n\t        inOrderTraverseNode(node.left, callback);\n\t        callback(node.key);\n\t        inOrderTraverseNode(node.right, callback);\n\t    }\n\t}\n\t\n\tfunction preOrderTraverseNode(node, callback) {\n\t    if (node !== null) {\n\t        callback(node.key);\n\t        preOrderTraverseNode(node.left, callback);\n\t        preOrderTraverseNode(node.right, callback);\n\t    }\n\t}\n\t\n\tfunction postOrderTraverseNode(node, callback) {\n\t    if (node !== null) {\n\t        postOrderTraverseNode(node.left, callback);\n\t        postOrderTraverseNode(node.right, callback);\n\t        callback(node.key);\n\t    }\n\t}\n\t\n\tfunction insertNewNode(node, newNode) {\n\t    if (newNode.key < node.key) {\n\t        if (node.left === null) {\n\t            node.left = newNode;\n\t        } else {\n\t            insertNewNode(node.left, newNode);\n\t        }\n\t    } else {\n\t        if (node.right === null) {\n\t            node.right = newNode;\n\t        } else {\n\t            insertNewNode(node.right, newNode);\n\t        }\n\t    }\n\t}\n\t\n\t/** Class representing a binary search tree */\n\t\n\tvar BinarySearchTree = exports.BinarySearchTree = function () {\n\t    /**\n\t     * Creates a binary search tree.\n\t     */\n\t    function BinarySearchTree() {\n\t        _classCallCheck(this, BinarySearchTree);\n\t\n\t        this.root = null;\n\t    }\n\t\n\t    /**\n\t     * Inserts key into tree.\n\t     * @param {*} key\n\t     */\n\t\n\t\n\t    _createClass(BinarySearchTree, [{\n\t        key: 'insert',\n\t        value: function insert(key) {\n\t            var node = new _BSTNode.BSTNode(key);\n\t            if (this.root === null) {\n\t                this.root = node;\n\t            } else {\n\t                insertNewNode.call(this, this.root, node);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Searches for given key.\n\t         * @param {*} key - Key to find.\n\t         * @returns {boolean} True if key is found, false if not.\n\t         */\n\t\n\t    }, {\n\t        key: 'search',\n\t        value: function search(key) {\n\t            return searchNode.call(this, this.root, key);\n\t        }\n\t\n\t        /**\n\t         * Traverse through tree in order, executing callback each time with key as argument.\n\t         * @param {function} callback - Callback to be executed.\n\t         */\n\t\n\t    }, {\n\t        key: 'inOrderTraverse',\n\t        value: function inOrderTraverse(callback) {\n\t            inOrderTraverseNode.call(this, this.root, callback);\n\t        }\n\t\n\t        /**\n\t         * Traverse through tree in pre-order, executing callback each time with key as argument.\n\t         * @param {function} callback - Callback to be executed.\n\t         */\n\t\n\t    }, {\n\t        key: 'preOrderTraverse',\n\t        value: function preOrderTraverse(callback) {\n\t            preOrderTraverseNode.call(this, this.root, callback);\n\t        }\n\t\n\t        /**\n\t         * Traverse through tree in post-order, executing callback each time with key as argument.\n\t         * @param {function} callback - Callback to be executed.\n\t         */\n\t\n\t    }, {\n\t        key: 'postOrderTraverse',\n\t        value: function postOrderTraverse(callback) {\n\t            postOrderTraverseNode.call(this, this.root, callback);\n\t        }\n\t\n\t        /**\n\t         * Returns minimum key in tree.\n\t         * @returns {*} Minimum key.\n\t         */\n\t\n\t    }, {\n\t        key: 'min',\n\t        value: function min() {\n\t            return minNode.call(this, this.root);\n\t        }\n\t\n\t        /**\n\t         * Returns maximum key in tree.\n\t         * @returns {*} Maximum key.\n\t         */\n\t\n\t    }, {\n\t        key: 'max',\n\t        value: function max() {\n\t            return maxNode.call(this, this.root);\n\t        }\n\t\n\t        /**\n\t         * Removes given key from tree.\n\t         * @param {*} key - Key to be removed.\n\t         * @returns {*|null} Key that was removed or null if it was not found.\n\t         */\n\t\n\t    }, {\n\t        key: 'remove',\n\t        value: function remove(key) {\n\t            return removeNode.call(this, this.root, key);\n\t        }\n\t    }]);\n\n\t    return BinarySearchTree;\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Graph = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Queue = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _verticesMap = new Map();\n\tvar _connectionsMap = new Map();\n\t\n\t/** Class representing an undirected graph. */\n\t\n\tvar Graph = exports.Graph = function () {\n\t    /**\n\t    * Creates a graph.\n\t    */\n\t    function Graph() {\n\t        _classCallCheck(this, Graph);\n\t\n\t        _verticesMap.set(this, []);\n\t        _connectionsMap.set(this, new Map());\n\t    }\n\t\n\t    /**\n\t     * Add given vertex to graph.\n\t     * @param {*} v - Vertex to add to graph.\n\t     */\n\t\n\t\n\t    _createClass(Graph, [{\n\t        key: 'add',\n\t        value: function add(v) {\n\t            _verticesMap.get(this).push(v);\n\t            _connectionsMap.get(this).set(v, []);\n\t        }\n\t\n\t        /**\n\t         * Remove given vertex from graph.\n\t         * @param {*} vertex - Vertex to be removed from graph.\n\t         */\n\t\n\t    }, {\n\t        key: 'remove',\n\t        value: function remove(vertex) {\n\t            var vertArr = _verticesMap.get(this);\n\t            vertArr.splice(vertArr.indexOf(vertex), 1);\n\t\n\t            var connections = _connectionsMap.get(this).get(vertex);\n\t            for (var i = 0; i < connections.length; i++) {\n\t                this.disconnect(vertex, connections[i]);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Connects two vertices with an edge.\n\t         * @param {*} vertex1 - First vertex to be connected to second vertex.\n\t         * @param {*} vertex2 - Second vertex to be connected to first vertex.\n\t         */\n\t\n\t    }, {\n\t        key: 'connect',\n\t        value: function connect(vertex1, vertex2) {\n\t            _connectionsMap.get(this).get(vertex1).push(vertex2);\n\t            _connectionsMap.get(this).get(vertex2).push(vertex1);\n\t        }\n\t\n\t        /**\n\t         * Disconnect two vertices.\n\t         * @param {*} vertex1 - First vertex to be disconnected from second vertex.\n\t         * @param {*} vertex2 - Second vertex to be disconnected from first vertex.\n\t         */\n\t\n\t    }, {\n\t        key: 'disconnect',\n\t        value: function disconnect(vertex1, vertex2) {\n\t            var arr1 = _connectionsMap.get(this).get(vertex1);\n\t            arr1.splice(arr1.indexOf(vertex2), 1);\n\t\n\t            var arr2 = _connectionsMap.get(this).get(vertex2);\n\t            arr2.splice(arr2.indexOf(vertex1), 1);\n\t        }\n\t\n\t        /**\n\t         * Checks if graph is empty.\n\t         * @returns {boolean} True if it's empty, false if it's not.\n\t         */\n\t\n\t    }, {\n\t        key: 'isEmpty',\n\t        value: function isEmpty() {\n\t            return _verticesMap.get(this).length === 0;\n\t        }\n\t\n\t        /**\n\t         * Gets string representation of graph.\n\t         * @returns {string} String representing graph.\n\t         */\n\t\n\t    }, {\n\t        key: 'toString',\n\t        value: function toString() {\n\t            var output = '';\n\t\n\t            for (var i = 0; i < _verticesMap.get(this).length; i++) {\n\t                output += _verticesMap.get(this)[i] + ' ->';\n\t                var connections = _connectionsMap.get(this).get(_verticesMap.get(this)[i]);\n\t                for (var y = 0; y < connections.length; y++) {\n\t                    output += ' ' + connections[y];\n\t                }\n\t                output += '\\n';\n\t            }\n\t\n\t            return output;\n\t        }\n\t\n\t        /**\n\t         * Removes all vertices from graph.\n\t         */\n\t\n\t    }, {\n\t        key: 'clear',\n\t        value: function clear() {\n\t            _verticesMap.set(this, []);\n\t            _connectionsMap.set(this, new Map());\n\t        }\n\t\n\t        /**\n\t         * Returns the number of vertices in graph.\n\t         * @returns {number} Number of vertices in graph.\n\t         */\n\t\n\t    }, {\n\t        key: 'size',\n\t        value: function size() {\n\t            return _verticesMap.get(this).length;\n\t        }\n\t\n\t        /**\n\t         * Checks whether given vertex is in graph.\n\t         * @param {*} vertex - Vertex to check.\n\t         * @returns {boolean} True if it is, false if it's not.\n\t         */\n\t\n\t    }, {\n\t        key: 'contains',\n\t        value: function contains(vertex) {\n\t            var index = _verticesMap.get(this).findIndex(function (element) {\n\t                return element === vertex;\n\t            });\n\t\n\t            return index >= 0 ? true : false;\n\t        }\n\t\n\t        /**\n\t         * Gets array of all connections to given vertex.\n\t         * @param {*} vertex - Vertex to get connections of.\n\t         * @returns {array} Of connected vertices to given vertex.\n\t         */\n\t\n\t    }, {\n\t        key: 'getVerticesConnectedTo',\n\t        value: function getVerticesConnectedTo(vertex) {\n\t            return _connectionsMap.get(this).get(vertex);\n\t        }\n\t\n\t        /**\n\t         * Gets an array of all vertices in graph.\n\t         * @returns {array} Array of all vertices in graph.\n\t         */\n\t\n\t    }, {\n\t        key: 'getAllVertices',\n\t        value: function getAllVertices() {\n\t            return _verticesMap.get(this);\n\t        }\n\t\n\t        /**\n\t         * Performs callback on every vertices in graph, passing vertices' value in as an argument.\n\t         * @param {function} callback - Callback to be executed on each vertex.\n\t         */\n\t\n\t    }, {\n\t        key: 'forEach',\n\t        value: function forEach(callback) {\n\t            var color = [],\n\t                queue = new _Queue.Queue();\n\t\n\t            // Enqueue the point of origin\n\t            queue.enqueue(_verticesMap.get(this)[0]);\n\t\n\t            // Initialize colors\n\t            for (var i = 0; i < _verticesMap.get(this).length; i++) {\n\t                color[_verticesMap.get(this)[i]] = 'white';\n\t            }\n\t\n\t            while (!queue.isEmpty()) {\n\t                var u = queue.dequeue(),\n\t                    neighbors = _connectionsMap.get(this).get(u);\n\t\n\t                // mark vertex u as visited\n\t                color[u] = 'grey';\n\t\n\t                // for each neighbor of vertex u, if unvisited, visit, add to queue and mark as visited\n\t                for (var _i = 0; _i < neighbors.length; _i++) {\n\t                    var w = neighbors[_i];\n\t                    if (color[w] === 'white') {\n\t                        color[w] = 'grey';\n\t                        queue.enqueue(w);\n\t                    }\n\t                }\n\t\n\t                // mark vertex u as discovered\n\t                color[u] = 'black';\n\t\n\t                // execute callback on vertex u\n\t                if (callback) {\n\t                    callback(u);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Returns an object containing keys for all vertices and values representing the distances they are from the given vertex.\n\t         * @param {*} vertex - Vertex to get distances from.\n\t         * @returns {object} Object containing distances.\n\t         */\n\t\n\t    }, {\n\t        key: 'getDistancesFrom',\n\t        value: function getDistancesFrom(vertex) {\n\t            var color = [],\n\t                queue = new _Queue.Queue(),\n\t                distances = {};\n\t\n\t            queue.enqueue(vertex);\n\t\n\t            // Initialize colors\n\t            for (var i = 0; i < _verticesMap.get(this).length; i++) {\n\t                color[_verticesMap.get(this)[i]] = 'white';\n\t            }\n\t\n\t            for (var _i2 = 0; _i2 < _verticesMap.get(this).length; _i2++) {\n\t                distances[_verticesMap.get(this)[_i2]] = 0;\n\t            }\n\t\n\t            while (!queue.isEmpty()) {\n\t                var u = queue.dequeue(),\n\t                    neighbors = _connectionsMap.get(this).get(u);\n\t\n\t                color[u] = 'grey';\n\t                for (var _i3 = 0; _i3 < neighbors.length; _i3++) {\n\t                    var w = neighbors[_i3];\n\t                    if (color[w] === 'white') {\n\t                        color[w] = 'grey';\n\t                        distances[w] = distances[u] + 1;\n\t                        queue.enqueue(w);\n\t                    }\n\t                }\n\t\n\t                color[u] = 'black';\n\t            }\n\t            return distances;\n\t        }\n\t    }]);\n\n\t    return Graph;\n\t}();\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.simpleHashCode = simpleHashCode;\n\tfunction simpleHashCode(key) {\n\t  var hash = 0;\n\t  for (var i = 0; i < key.length; i++) {\n\t    hash += key.charCodeAt(i);\n\t  }\n\t  return hash % 37;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.HashTable = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _HashCodes = __webpack_require__(6);\n\t\n\tvar _ValuePair = __webpack_require__(8);\n\t\n\tvar _LinkedList = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/** Class representing a hash table which maps keys to values. */\n\tvar HashTable = exports.HashTable = function () {\n\t  /**\n\t   * Creates a hash table.\n\t   */\n\t  function HashTable() {\n\t    _classCallCheck(this, HashTable);\n\t\n\t    this.table = [];\n\t  }\n\t\n\t  /**\n\t   * Gets value at given key.\n\t   * @param {*} key - Key of the element to get.\n\t   * @returns {*|undefined} Returns element at given key, or undefined if no item is found.\n\t   */\n\t\n\t\n\t  _createClass(HashTable, [{\n\t    key: 'get',\n\t    value: function get(key) {\n\t      var position = (0, _HashCodes.simpleHashCode)(key);\n\t\n\t      if (this.table[position] !== undefined) {\n\t        var current = this.table[position].head;\n\t\n\t        // loop from 1st element through to n minus 1th element\n\t        while (current.next) {\n\t          if (current.element.key === key) {\n\t            return current.element.value;\n\t          } else {\n\t            current = current.next;\n\t          }\n\t        }\n\t\n\t        // check last element\n\t        if (current.element.key === key) {\n\t          return current.element.value;\n\t        }\n\t      }\n\t      return undefined;\n\t    }\n\t\n\t    /**\n\t     * Put value in table at given key.\n\t     * @param {*} key - Key where to put given value.\n\t     * @param {*} value - Value to put at given key.\n\t     */\n\t\n\t  }, {\n\t    key: 'put',\n\t    value: function put(key, value) {\n\t      var position = (0, _HashCodes.simpleHashCode)(key);\n\t\n\t      if (this.table[position] === undefined) {\n\t        this.table[position] = new _LinkedList.LinkedList();\n\t      }\n\t\n\t      this.table[position].append(new _ValuePair.ValuePair(key, value));\n\t    }\n\t\n\t    /**\n\t     * Remove the value at the given key.\n\t     * @param {*} key - Key of value to remove.\n\t     * @returns {boolean} True if remove is successful, false if it is not.\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(key) {\n\t      var position = (0, _HashCodes.simpleHashCode)(key);\n\t\n\t      if (this.table[position] !== undefined) {\n\t        var current = this.table[position].head;\n\t\n\t        // loop from 1st element through to n minus 1th element\n\t        while (current.next) {\n\t          if (current.element.key === key) {\n\t            this.table[position].remove(current.element);\n\t            if (this.table[position].isEmpty()) {\n\t              this.table[position] = undefined;\n\t            }\n\t            return true;\n\t          } else {\n\t            current = current.next;\n\t          }\n\t        }\n\t\n\t        // check last element\n\t        if (current.element.key === key) {\n\t          this.table[position].remove(current.element);\n\t          if (this.table[position].isEmpty()) {\n\t            this.table[position] = undefined;\n\t          }\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t  }]);\n\n\t  return HashTable;\n\t}();\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ValuePair = exports.ValuePair = function () {\n\t  function ValuePair(key, value) {\n\t    _classCallCheck(this, ValuePair);\n\t\n\t    this.key = key;\n\t    this.value = value;\n\t  }\n\t\n\t  _createClass(ValuePair, [{\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return \"[\" + this.key + \" - \" + this.value + \"]\";\n\t    }\n\t  }]);\n\n\t  return ValuePair;\n\t}();\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LinkedListNode = exports.LinkedListNode = function LinkedListNode(element) {\n\t  _classCallCheck(this, LinkedListNode);\n\t\n\t  this.element = element;\n\t  this.next = null;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar map = new WeakMap();\n\t\n\t/** Class representing a last-in-first-out (LIFO) stack of elements. */\n\t\n\tvar Stack = exports.Stack = function () {\n\t  /**\n\t   * Creates a stack.\n\t   */\n\t  function Stack() {\n\t    _classCallCheck(this, Stack);\n\t\n\t    map.set(this, []);\n\t  }\n\t\n\t  /**\n\t   * Get a string representation of the stack.\n\t   * @returns {string} The string representation of stack.\n\t   */\n\t\n\t\n\t  _createClass(Stack, [{\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      var stack = map.get(this);\n\t      return stack.toString();\n\t    }\n\t\n\t    /**\n\t     * Gets and removes the last element in stack.\n\t     * @returns {*} The last element in stack.\n\t     */\n\t\n\t  }, {\n\t    key: \"pop\",\n\t    value: function pop() {\n\t      var stack = map.get(this);\n\t      return stack.pop();\n\t    }\n\t\n\t    /**\n\t     * Pushes an element onto stack.\n\t     * @param {*} element - Element to be added to stack.\n\t     */\n\t\n\t  }, {\n\t    key: \"push\",\n\t    value: function push(element) {\n\t      var stack = map.get(this);\n\t      stack.push(element);\n\t    }\n\t\n\t    /**\n\t     * Gets the size of stack.\n\t     * @returns {number} The size of stack.\n\t     */\n\t\n\t  }, {\n\t    key: \"size\",\n\t    value: function size() {\n\t      var stack = map.get(this);\n\t      return stack.length;\n\t    }\n\t\n\t    /**\n\t     * Checks whether or not the stack is empty.\n\t     * @returns {boolean} True if the stack's empty, false if it's not.\n\t     */\n\t\n\t  }, {\n\t    key: \"isEmpty\",\n\t    value: function isEmpty() {\n\t      var stack = map.get(this);\n\t      return stack.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Removes all elements from stack.\n\t     */\n\t\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      var stack = map.get(this);\n\t      stack.splice(0, stack.length);\n\t    }\n\t  }]);\n\n\t  return Stack;\n\t}();\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// structd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9918e679a8f010d68b77","import { Stack } from './structures/stack/Stack';\nimport { Queue } from './structures/queue/Queue';\nimport { LinkedList } from './structures/linked-list/LinkedList';\nimport { HashTable } from './structures/hash-table/HashTable';\nimport { BinarySearchTree } from './structures/binary-search-tree/BinarySearchTree';\nimport { Graph } from './structures/graph/Graph';\n\nexport { Stack, Queue, LinkedList, HashTable, BinarySearchTree, Graph };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { LinkedListNode } from './LinkedListNode.js';\n\n/** Class representing a singly linked list of elements. */\nexport class LinkedList {\n  /**\n   * Creates a linked list.\n   */\n  constructor() {\n    this.length = 0;\n    this.head = null;\n  }\n\n  /**\n   * Appends an element to the end of list.\n   * @param {*} element - Element to be appended to list.\n   */\n  append(element) {\n    let\n      node = new LinkedListNode(element),\n      current;\n\n    // Check if this is 1st item in list\n    if (this.head === null) {\n      this.head = node;\n    } else {\n      current = this.head;\n\n      // Loop to last node in list\n      while (current.next) {\n        current = current.next;\n      }\n\n      current.next = node;\n    }\n\n    this.length++;\n  }\n\n  /**\n   * Inserts an element into the list at a given position.\n   * @param {number} position - Position to insert new element.\n   * @param {*} element - Element to be inserted into list.\n   */\n  insert(position, element) {\n    let\n      node = new LinkedListNode(element),\n      prevPosition = position - 1,\n      prevNode = this.head,\n      nextNode;\n\n      // Get previous element\n      for (let i = 0; i < prevPosition; i++) {\n        prevNode = prevNode.next;\n      }\n\n      nextNode = prevNode.next;\n      prevNode.next = node;\n      node.next = nextNode;\n  }\n\n  /**\n   * Removes element from list at given position\n   * @param {number} position - Position where element to be removed is.\n   */\n  removeAt(position) {\n    if (position > -1 && position < this.length && this.head != null) {\n      let\n        prevPosition = position - 1,\n        current = this.head;\n\n      if (position === 0) {\n        this.head = current.next;\n      } else {\n        // Get previous element\n        for (let i = 0; i < prevPosition; i++) {\n          current = current.next;\n        }\n\n        // Assign previous elements next to the element after the element being\n        // replaced\n        current.next = current.next.next;\n      }\n    }\n  }\n\n  /**\n   * Removes given element from list.\n   * @param {*} element - Element to be removed.\n   */\n  remove(element) {\n    let position = this.indexOf(element);\n    this.removeAt(position);\n  }\n\n  /**\n   * Get the index of a given element.\n   * @param {*} element - Element who's index is needed.\n   * @returns {number} Index of given element.\n   */\n  indexOf(element) {\n    let\n      index = 0,\n      current;\n\n    if (this.head) {\n      current = this.head;\n      while (current) {\n        if (current.element === element) return index;\n        index++;\n        current = current.next;\n      }\n    }\n\n    // Will only be reached if element not found in list\n    return -1;\n  }\n\n  /**\n   * Checks whether or not the list is empty.\n   * @returns {boolean} True if the list's empty, false if it's not.\n   */\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  /**\n   * Gets the size of list.\n   * @returns {number} The size of list.\n   */\n  size() {\n    return this.length;\n  }\n\n  /**\n   * Get a string representation of the list.\n   * @returns {string} The string representation of list.\n   */\n  toString() {\n    let\n      current = this.head,\n      string = '';\n\n    while(current) {\n      string += current.element + ', ';\n      current = current.next;\n    }\n\n    // Remove trailing space and comma\n    string = string.substring(0, string.length - 2);\n\n    return string;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/linked-list/LinkedList.js","let map = new WeakMap();\n\n/** Class representing a first-in-first-out (FIFO) queue of elements. */\nexport class Queue {\n  /**\n   * Creates a queue.\n   */\n  constructor() {\n    map.set(this, []);\n  }\n\n  /**\n   * Get a string representation of queue.\n   * @returns {string} The string representation of queue.\n   */\n  toString() {\n    let queue = map.get(this);\n    return queue.toString();\n  }\n\n  /**\n   * Removes the first element from the queue.\n   * @returns {*} Element removed from queue.\n   */\n  dequeue() {\n    let queue = map.get(this);\n    return queue.shift();\n  }\n\n  /**\n   * Places an element onto queue.\n   * @param {*} element - Element to be added to queue.\n   */\n  enqueue(element) {\n    let queue = map.get(this);\n    queue.push(element);\n  }\n\n  /**\n   * Gets the size of queue.\n   * @returns {number} The size of queue.\n   */\n  size() {\n    let queue = map.get(this);\n    return queue.length;\n  }\n\n  /**\n   * Checks whether queue is empty.\n   * @returns {boolean} True if empty, false if not.\n   */\n  isEmpty() {\n    let queue = map.get(this);\n    return queue.length === 0;\n  }\n\n  /**\n   * Gets first element of queue without removing it.\n   * @returns {*} First element of queue.\n   */\n  front() {\n    let queue = map.get(this);\n    return queue[0];\n  }\n\n  /**\n   * Removes all elements from queue.\n   */\n  clear() {\n    let queue = map.get(this);\n    queue.splice(0, queue.length);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/queue/Queue.js","export class BSTNode {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/structures/binary-search-tree/BSTNode.js","import { BSTNode } from './BSTNode.js';\n\n// --------------------------------------------------------------------\n// Private Methods\n// --------------------------------------------------------------------\n\nfunction minNode(node) {\n    if (node && node.left !== null) {\n        return minNode(node.left);\n    } else {\n        return node.key;\n    }\n}\n\nfunction maxNode(node) {\n    if (node && node.right !== null) {\n        return maxNode(node.right);\n    } else {\n        return node.key;\n    }\n}\n\nfunction searchNode(node, key) {\n    if (node === null) {\n        return false;\n    }\n\n    if (node.key === key) {\n        return true;\n    }\n\n    if (key < node.key) {\n        return searchNode(node.left, key);\n    } else {\n        return searchNode(node.right, key);\n    }\n}\n\n// Method remove the node with matching key from the tree and returns it\nfunction removeNode(node, key) {\n    // make sure node exists\n    if (node === null) {\n        return null;\n    }\n\n    // If the current node's key is not the correct key, remove it and return it\n    if (key === node.key) {\n\n        // Case 1: The node is a leaf node\n        if (node.left === null && node.right === null) {\n            node = null;\n            return node;\n        }\n\n        // Case 2: The node only has a right child\n        if (node.left === null) {\n            node = node.right;\n            return node;\n        }\n\n        // Case 3: The node only has a left child\n        if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n\n        // Case 4: The node as 2 children\n        let tmp = minNode(node.right);\n        node.key = tmp.key;\n        node.right = removeNode(node.right, tmp.key);\n        return node;\n    }\n\n    // If the current node's key is not the correct key, find the right node by\n    // traversing down either the left branch or right branch recursively\n    if (key < node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key > node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    }\n}\n\nfunction inOrderTraverseNode(node, callback) {\n    if (node !== null) {\n        inOrderTraverseNode(node.left, callback);\n        callback(node.key);\n        inOrderTraverseNode(node.right, callback);\n    }\n}\n\nfunction preOrderTraverseNode(node, callback) {\n    if (node !== null) {\n        callback(node.key);\n        preOrderTraverseNode(node.left, callback);\n        preOrderTraverseNode(node.right, callback);\n    }\n}\n\nfunction postOrderTraverseNode(node, callback) {\n    if (node !== null) {\n        postOrderTraverseNode(node.left, callback);\n        postOrderTraverseNode(node.right, callback);\n        callback(node.key);\n    }\n}\n\nfunction insertNewNode(node, newNode) {\n    if (newNode.key < node.key) {\n        if (node.left === null) {\n            node.left = newNode;\n        } else {\n          insertNewNode(node.left, newNode);\n        }\n    } else {\n        if (node.right === null) {\n            node.right = newNode;\n        } else {\n            insertNewNode(node.right, newNode);\n        }\n    }\n}\n\n/** Class representing a binary search tree */\nexport class BinarySearchTree {\n  /**\n   * Creates a binary search tree.\n   */\n  constructor() {\n    this.root = null;\n  }\n\n  /**\n   * Inserts key into tree.\n   * @param {*} key\n   */\n  insert(key) {\n      let node = new BSTNode(key);\n      if (this.root === null) {\n          this.root = node;\n      } else {\n          insertNewNode.call(this, this.root, node);\n      }\n  }\n\n  /**\n   * Searches for given key.\n   * @param {*} key - Key to find.\n   * @returns {boolean} True if key is found, false if not.\n   */\n  search(key) {\n      return searchNode.call(this, this.root, key);\n  }\n\n  /**\n   * Traverse through tree in order, executing callback each time with key as argument.\n   * @param {function} callback - Callback to be executed.\n   */\n  inOrderTraverse(callback) {\n      inOrderTraverseNode.call(this, this.root, callback);\n  }\n\n  /**\n   * Traverse through tree in pre-order, executing callback each time with key as argument.\n   * @param {function} callback - Callback to be executed.\n   */\n  preOrderTraverse(callback) {\n      preOrderTraverseNode.call(this, this.root, callback);\n  }\n\n  /**\n   * Traverse through tree in post-order, executing callback each time with key as argument.\n   * @param {function} callback - Callback to be executed.\n   */\n  postOrderTraverse(callback) {\n      postOrderTraverseNode.call(this, this.root, callback);\n  }\n\n  /**\n   * Returns minimum key in tree.\n   * @returns {*} Minimum key.\n   */\n  min() {\n      return minNode.call(this, this.root);\n  }\n\n  /**\n   * Returns maximum key in tree.\n   * @returns {*} Maximum key.\n   */\n  max() {\n      return maxNode.call(this, this.root);\n  }\n\n  /**\n   * Removes given key from tree.\n   * @param {*} key - Key to be removed.\n   * @returns {*|null} Key that was removed or null if it was not found.\n   */\n  remove(key) {\n      return removeNode.call(this, this.root, key);\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/binary-search-tree/BinarySearchTree.js","import { Queue } from '../queue/Queue';\n\nlet _verticesMap = new Map();\nlet _connectionsMap = new Map();\n\n/** Class representing an undirected graph. */\nexport class Graph {\n  /**\n  * Creates a graph.\n  */\n  constructor() {\n    _verticesMap.set(this, []);\n    _connectionsMap.set(this, new Map());\n  }\n\n  /**\n   * Add given vertex to graph.\n   * @param {*} v - Vertex to add to graph.\n   */\n  add(v) {\n    _verticesMap.get(this).push(v);\n    _connectionsMap.get(this).set(v, []);\n  }\n\n  /**\n   * Remove given vertex from graph.\n   * @param {*} vertex - Vertex to be removed from graph.\n   */\n  remove(vertex) {\n    let vertArr = _verticesMap.get(this);\n    vertArr.splice(vertArr.indexOf(vertex), 1);\n\n    let connections = _connectionsMap.get(this).get(vertex);\n    for (let i = 0; i < connections.length; i++) {\n        this.disconnect(vertex, connections[i]);\n    }\n  }\n\n  /**\n   * Connects two vertices with an edge.\n   * @param {*} vertex1 - First vertex to be connected to second vertex.\n   * @param {*} vertex2 - Second vertex to be connected to first vertex.\n   */\n  connect(vertex1, vertex2) {\n    _connectionsMap.get(this).get(vertex1).push(vertex2);\n    _connectionsMap.get(this).get(vertex2).push(vertex1);\n  }\n\n  /**\n   * Disconnect two vertices.\n   * @param {*} vertex1 - First vertex to be disconnected from second vertex.\n   * @param {*} vertex2 - Second vertex to be disconnected from first vertex.\n   */\n  disconnect(vertex1, vertex2) {\n    let arr1 = _connectionsMap.get(this).get(vertex1);\n    arr1.splice(arr1.indexOf(vertex2), 1);\n\n    let arr2 = _connectionsMap.get(this).get(vertex2);\n    arr2.splice(arr2.indexOf(vertex1), 1);\n  }\n\n  /**\n   * Checks if graph is empty.\n   * @returns {boolean} True if it's empty, false if it's not.\n   */\n  isEmpty() {\n      return _verticesMap.get(this).length === 0;\n  }\n\n  /**\n   * Gets string representation of graph.\n   * @returns {string} String representing graph.\n   */\n  toString() {\n      let output = '';\n\n      for (let i = 0; i < _verticesMap.get(this).length; i++) {\n          output += `${_verticesMap.get(this)[i]} ->`;\n          let connections = _connectionsMap.get(this).get(_verticesMap.get(this)[i]);\n          for (let y = 0; y < connections.length; y++) {\n              output += ` ${connections[y]}`;\n          }\n          output += '\\n';\n      }\n\n      return output;\n  }\n\n  /**\n   * Removes all vertices from graph.\n   */\n  clear() {\n      _verticesMap.set(this, []);\n      _connectionsMap.set(this, new Map());\n  }\n\n  /**\n   * Returns the number of vertices in graph.\n   * @returns {number} Number of vertices in graph.\n   */\n  size() {\n    return _verticesMap.get(this).length;\n  }\n\n  /**\n   * Checks whether given vertex is in graph.\n   * @param {*} vertex - Vertex to check.\n   * @returns {boolean} True if it is, false if it's not.\n   */\n  contains(vertex) {\n    let index = _verticesMap.get(this).findIndex((element) => {\n      return  element === vertex;\n    });\n\n    return index >= 0 ? true : false;\n  }\n\n  /**\n   * Gets array of all connections to given vertex.\n   * @param {*} vertex - Vertex to get connections of.\n   * @returns {array} Of connected vertices to given vertex.\n   */\n  getVerticesConnectedTo(vertex) {\n    return _connectionsMap.get(this).get(vertex);\n  }\n\n  /**\n   * Gets an array of all vertices in graph.\n   * @returns {array} Array of all vertices in graph.\n   */\n  getAllVertices() {\n      return _verticesMap.get(this);\n  }\n\n  /**\n   * Performs callback on every vertices in graph, passing vertices' value in as an argument.\n   * @param {function} callback - Callback to be executed on each vertex.\n   */\n  forEach(callback) {\n      let\n          color = [],\n          queue = new Queue();\n\n      // Enqueue the point of origin\n      queue.enqueue(_verticesMap.get(this)[0]);\n\n      // Initialize colors\n      for (let i = 0; i < _verticesMap.get(this).length; i++) {\n          color[_verticesMap.get(this)[i]] = 'white';\n      }\n\n      while (!queue.isEmpty()) {\n          let u         = queue.dequeue(),\n              neighbors = _connectionsMap.get(this).get(u);\n\n          // mark vertex u as visited\n          color[u] = 'grey';\n\n          // for each neighbor of vertex u, if unvisited, visit, add to queue and mark as visited\n          for (let i = 0; i < neighbors.length; i++) {\n              let w = neighbors[i];\n              if (color[w] === 'white') {\n                  color[w] = 'grey';\n                  queue.enqueue(w);\n              }\n          }\n\n          // mark vertex u as discovered\n          color[u] = 'black';\n\n          // execute callback on vertex u\n          if (callback) {\n              callback(u);\n          }\n      }\n  }\n\n  /**\n   * Returns an object containing keys for all vertices and values representing the distances they are from the given vertex.\n   * @param {*} vertex - Vertex to get distances from.\n   * @returns {object} Object containing distances.\n   */\n  getDistancesFrom(vertex) {\n      let color = [],\n          queue = new Queue(),\n          distances = {};\n\n      queue.enqueue(vertex);\n\n      // Initialize colors\n      for (let i = 0; i < _verticesMap.get(this).length; i++) {\n          color[_verticesMap.get(this)[i]] = 'white';\n      }\n\n      for (let i = 0; i < _verticesMap.get(this).length; i++) {\n          distances[_verticesMap.get(this)[i]] = 0;\n      }\n\n      while (!queue.isEmpty()) {\n          let u         = queue.dequeue(),\n              neighbors = _connectionsMap.get(this).get(u);\n\n          color[u] = 'grey';\n          for (let i = 0; i < neighbors.length; i++) {\n              let w = neighbors[i];\n              if (color[w] === 'white') {\n                  color[w] = 'grey';\n                  distances[w] = distances[u] + 1;\n                  queue.enqueue(w);\n              }\n          }\n\n          color[u] = 'black';\n      }\n      return distances;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/structures/graph/Graph.js","export function simpleHashCode(key) {\n  let hash = 0;\n  for (let i = 0; i < key.length; i++) {\n    hash += key.charCodeAt(i);\n  }\n  return hash % 37;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/hash-table/HashCodes.js","import { simpleHashCode } from './HashCodes.js';\nimport { ValuePair } from './ValuePair.js';\nimport { LinkedList } from '../linked-list/LinkedList.js';\n\n/** Class representing a hash table which maps keys to values. */\nexport class HashTable {\n  /**\n   * Creates a hash table.\n   */\n  constructor() {\n    this.table = [];\n  }\n\n  /**\n   * Gets value at given key.\n   * @param {*} key - Key of the element to get.\n   * @returns {*|undefined} Returns element at given key, or undefined if no item is found.\n   */\n  get(key) {\n    let position = simpleHashCode(key);\n\n    if (this.table[position] !== undefined) {\n      let current = this.table[position].head;\n\n      // loop from 1st element through to n minus 1th element\n      while (current.next) {\n        if (current.element.key === key) {\n          return current.element.value;\n        } else {\n          current = current.next;\n        }\n      }\n\n      // check last element\n      if (current.element.key === key) {\n        return current.element.value;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Put value in table at given key.\n   * @param {*} key - Key where to put given value.\n   * @param {*} value - Value to put at given key.\n   */\n  put(key, value) {\n    let position = simpleHashCode(key);\n\n    if (this.table[position] === undefined) {\n      this.table[position] = new LinkedList();\n    }\n\n    this.table[position].append(new ValuePair(key, value));\n  }\n\n  /**\n   * Remove the value at the given key.\n   * @param {*} key - Key of value to remove.\n   * @returns {boolean} True if remove is successful, false if it is not.\n   */\n  remove(key) {\n    let position = simpleHashCode(key);\n\n    if (this.table[position] !== undefined) {\n      let current = this.table[position].head;\n\n      // loop from 1st element through to n minus 1th element\n      while (current.next) {\n        if (current.element.key === key) {\n          this.table[position].remove(current.element);\n          if (this.table[position].isEmpty()) {\n            this.table[position] = undefined;\n          }\n          return true;\n        } else {\n          current = current.next;\n        }\n      }\n\n      // check last element\n      if (current.element.key === key) {\n        this.table[position].remove(current.element);\n        if (this.table[position].isEmpty()) {\n          this.table[position] = undefined;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/hash-table/HashTable.js","export class ValuePair {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  toString() {\n    return `[${this.key} - ${this.value}]`;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/hash-table/ValuePair.js","export class LinkedListNode {\n  constructor(element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/linked-list/LinkedListNode.js","let map = new WeakMap();\n\n/** Class representing a last-in-first-out (LIFO) stack of elements. */\nexport class Stack {\n  /**\n   * Creates a stack.\n   */\n  constructor() {\n    map.set(this, []);\n  }\n\n  /**\n   * Get a string representation of the stack.\n   * @returns {string} The string representation of stack.\n   */\n  toString() {\n    let stack = map.get(this);\n    return stack.toString();\n  }\n\n  /**\n   * Gets and removes the last element in stack.\n   * @returns {*} The last element in stack.\n   */\n  pop() {\n    let stack = map.get(this);\n    return stack.pop();\n  }\n\n  /**\n   * Pushes an element onto stack.\n   * @param {*} element - Element to be added to stack.\n   */\n  push(element) {\n    let stack = map.get(this);\n    stack.push(element);\n  }\n\n  /**\n   * Gets the size of stack.\n   * @returns {number} The size of stack.\n   */\n  size() {\n    let stack = map.get(this);\n    return stack.length;\n  }\n\n  /**\n   * Checks whether or not the stack is empty.\n   * @returns {boolean} True if the stack's empty, false if it's not.\n   */\n  isEmpty() {\n    let stack = map.get(this);\n    return stack.length === 0;\n  }\n\n  /**\n   * Removes all elements from stack.\n   */\n  clear() {\n    let stack = map.get(this);\n    stack.splice(0, stack.length);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/structures/stack/Stack.js"],"sourceRoot":""}